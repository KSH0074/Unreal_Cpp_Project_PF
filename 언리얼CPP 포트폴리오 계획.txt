프로젝트 마무리 단계에서 개선사항으로 검색하여 개선된 사항을 지우고 
개선되지 않은 사항(기술적 부채)을 확인하여 가능한 부채 줄이기

------------------------------------------------------------------------------------
프로토타입 세부사항 : 

임시 캐릭터는 언리얼에서 제공하는Character Modeling 사용 

커맨드 저장했다 기술표랑 비교해서 맞는 기술을 보여야 하는데 

캐릭터에 붙어야 하는 컴포넌트, 
movement(기본)/ 카메라/ 스프링암 

------------------------------------------------------------------------------------
커맨드 입력 알고리즘? 
커맨드 핸들러가 필요하지 않을까 

키 입력 ->일정시간 지나면(0.5초?) 자동 휘발 
입력과 동시에 타이머 재생, 다음 키 입력시 타이머 초기화(갱신), 좌 클릭시 

커맨드 입력처리 => 기술표에 없으면 => False 
				     있는경우 => 맞는 기술 발사 

Queue으로 커맨드 입력을 받아서 데이터 테이블과 비교, 있으면 기술 사용, 

트라이(Trie 알고리즘) 사용? 아니면 배열 비교 형식으로? 흐으음 
그러면 기술표는 어떻게 만드는가?  

https://awayteamkiller.tistory.com/2 => 사용하지 않음
 

CSV 파일을 따로 만들었다 로드하여 사용

=>외부CSV 파일을 토대로 언리얼에 임포트하여 사용 
CommandDataTable c++ 파일 생성,

이 부분에서 많은 시간이 소요될 듯?   => 생각보다 일찍 끝났다.. 

각 레벨별 데미지 추가하기 => TABLE 또는 그래프 이용/PFGameInstance에서 로드 및 탐색기능구현 
---------------------------------------------------------------------------------------
적 FSM 제작 및 BB를 이용해서 AI가 컨트롤 하도록 함,
랜덤 패트롤 => 시야 내 플레이어 탐지 => 달려오기 => 공격 

FSM을 추가하던가 아무튼 피격효과도 추가해야함 
피격 모션도 있어야 함

커맨드 입력후 애니메이션 작동중에는 커맨드 아웃풋 안되게 해야 함 

capsule은 피격, 

Fireball 데미지를 Table에서 가져올 수 있도록함

FSM을 추가하던가 아무튼 피격효과도 추가해야함 => FSM대신 BehaviorTree를 이용해 구현됨. 일단 0.5초 정지로 .. 


이제 Enemy의 health가 0이하로 되었을때 사라지는 효과 조정 => 일단 밑으로 사라지도록 함 
스텐실 버퍼? 를 이용해서 벽 뒤에 있을 때 플레이어 보이게 하기  or 벽이 투명해지던가 하기 => 씬 뎁스를 이용해서 구현 가능할 것 같음 =>일단 보류



피격 모션도 있어야 함-> 일단 피격후 0.5초간 정지하도록 구현하였고 이 시간동안 피격 애니메이션 작동하도록 만들어야 하는데..  



의문 : 프로토타입 / 알파 / 베타 버전을 구분하는 것이 의미있는 행위인가? 


-----------------------------------
*중간 정리*

0-5.thisPointer 대체 및 피드백 내용 적용 
※피드백 내용 적용중 발견한 Behavior Tree 의 큰 기술적 부채를 발견,
BT/ BB 에서 Is too far 의 Bool 값이 유지가 되어야 하는데 계속 True 로 돌아가는 문제를 해결해야 코드가 간결해질 가능성이 높다. 또한 Enemy가 피격되면 플레이어를 쫓아가는 부분 또한 비슷한 방법으로 해결 될 듯 싶음, 이 기술적 부채의 큰 이유는 주먹구구식으로 제대로 배우지 않고 BT/BTT 등을 코드로 구현하려다 생긴 것  

1.Enemy 공격구현, 애니메이션은 아니더라도 공격을 한다는 함수 만들어서 작동되는지, BehaviorTree에 추가구현, (조건 : 거리, float) 
2.레벨별 기술 데미지 구현(커맨드 Csv파일을 수정해야할 듯)
3.이동지점 표시 (생각해보니 되게 독립적인 기능=> 앞으로 개발 순서에 상관없이 구현가능함 ) 
...

를 해결하고 난 이후 생각해야하는 것 
1.공격, 피격 판정 및 모션 =>공격 애니메이션에 notify로 피격, 공격 판정? 공격은 Skeletal 메시에 콜리전 구성해서 만들어야 하나? 피격 모션 중에 맞으면 피격처리를 해야하나?
공격 모션 중간(적당히 알맞은 부분)에 콜리전 충돌 판정이 켜지는 방식이어야 하나? ++ 

1-2.공격 애니메이션 작동중에는 커맨드 아웃풋 안되게 해야 함 
-> 함수에 bool형을 받는 매개변수를 달기 또는  애니메이션 노티파이로 구현해야하지 않을까(if문 사용해서 애니메이션 끝남 판정?), 이 게임에 선입력 시스템이 존재해야 하는가? =>yes 

2.UX/UI =>Esc 누르면 초기화면으로 갈지 설정을 조정할지 떠야하고 이때 시간은 멈추고 커맨드, 이동 관련된 입력은 중지되어야 한다.

3.레벨디자인? => 랜드스케이프 모드, 마켓플레이스 무료 콘텐츠 뒤지다 보면 쓸만한게 나오겠지... 별도의 프로젝트에 받고 필요한 콘텐츠만 이주하여 만들기, 일단 1개만  

4.초기화면 (시작 , 설정 , 등등 ) 

5.모듈화(?), 리팩토링 (및 기술적 부채 해결)

6.카메라 무빙 관련 조정 if 벽 투시효과 주지 않는경우  

추가를 고려하고 있는 사항  
1.Save/Load
2.커스텀 뎁스(?)사용해서 투시효과 주기 
3.FireBall이 시간이 아닌 날아간 거리에 따라 delete되도록 함//근데 거리 = 시간 * 속력 이므로 큰 차이없어보이나 유지보수에 용이할 것으로 판단, 다른 게임들 보면 투사 공격은 소멸판정이 거리이므로 플레이어가 좀더 직관적으로 판단 가능할 것으로 사료됨 
4.몬스터 헌터, 다크소울과 같은 패턴형 공격을 하는 보스 몹 (유니티로 만든 적이 있으나 언리얼 엔진 기능 사용이 아직 미숙하므로 난항이 예상됨)
5.공격 유형별 몹 피격반응 (애니메이션 다양하게 필요함 ...)
6.사운드(소스 구하기 힘들어 보임)
7.미니맵<-어렵진 않아보임 (별도의 이미지 파일 없이) 
8.포스트프로세스 

--------------------------------------------------------------------------
피드백 결과 

1. 코드정리 필요 함수 디폴트 리턴 (설명을 이해 못함?) 
2. thispointer 자제하기 (23/05/24 해결)
3.옵션 지정 >> ?? 아마도 일부 함수에서 옵션을 다 안쓰고 디폴트 매개변수로 때운 듯? UE4 Document 확인하면서 다시 작성해보기  
4.코드사용 => 사용할거면 완전하게, 애매하면 지우기 => 어느 부분인지? 모르겠지만 일단 코드 다시 살펴보면서 수정해보기 짚히는건 억지로 Blueprint에 넣은 C++함수 (추후 AI 재정리하면서 해결)
5.어떤 게임인지 흐름이 모르겠다, 왜 액션? 정리가 필요하다  => 전체계획 파일 세부화 작성 (설명 파일 추가로 해결되었을 것)
---------------------------------------------------------
2023-07-06 이후 작성된 부분 

포트폴리오의 진도 및 의욕 향상을 위해 피드백 내용은 최종적으로 적용하는 것으로 함
일단 애니메이션 관련 작업부터 시작하여 기본적인 기능을 먼저 완성하는 것이 목표


Mixamo에서 캐릭터를 다운받아 사용, Mixamo 캐릭터 Rig을 기준으로 Unreal기본 캐릭터 Animation 리타기팅 
Mixamo Character<<Retargetting<<UE4_Mannequin_Skeleton Rigging 기반 애니메이션 

>> 게임내 사용되는 캐릭터는 Mixamo에서 받은 캐릭터, 이를 기준으로 애니메이션을 적용한다. 

Mixamo 캐릭터를 Blender를 통해 UnrealEngine 에 맞게 변환하는 과정이 제대로 이루어지지 않아
휴머노이드 리타기팅은 수동으로 한다. 

필요한 애니메이션 모션 
공통구현사항 스킬 사용중에는 이동이 멈춰야함 

Enemy(normal mob) : 피격 , 공격 , 이동(새로운 모션을 구하여 추가하면 좋다. 여력이 되지 않을 경우 기본 애니메이션을 사용한다)

Player :
- fire ball, 일명 아도겐 모션, 구할 수 없으면 다른 투사체 발사 모션으로 대체한다, 커맨드리스트에 JangPoong으로 되어있으므로 추후 명칭 통합해야한다. 해당 애니메이션을 적당히 잘라서 
 투사체 생성과 애니메이션을 자연스럽게 만들어야 한다, 투사체 생성 타이밍을 맞추기 힘들경우 애니메이션 노티파이 기능 사용을 해야할 것.

- Hold 애니메이션은 개발역량 부족으로 다른 기술로 대체 , 일반 몹을 잡고 던지는 격투게임같은 동작, 역량도 떨어질 뿐더러 개발 방향성과 부적합, 
  게임 로스트아크의 컨텐츠 카오스던전이 레퍼런스이므로. 다른 공격 스킬 모션으로 대체한다. 빠르게 이동하여 공격하는 종류가 좋을 것


- Dodge 애니메이션, 회피 애니메이션으로, 해당 동작중엔 피격판정이 없어야 한다. 가장 구하기 쉬운 애니메이션이다. 루트모션이다.
- 피격 애니메이션 준비, 일종의 경직 상태로 상정하고 개발한다.(이동불가, 회전불가 = 마우스 입력 무시? / 키 입력은 가능 )

위를 베이스애니메이션이라 하고 
추후 스킬을 추가할 경우에따라 추가된다.

애니메이션 적용및 추가에 착오가 없도록 주의할 것 

위 애니메이션을 적용하려면, Enemy의 AI에 공격 패턴을 추가해야한다. 
이때 공격판정 범위는 공격 애니메이션을 참고 한다.


Enemy의 AI 중 탐지거리 밖에서 공격하는 경우에도 플레이어를 추적하도록 해야한다. 
따라서 Enemy AI 재정비 필요하다. 

Enemy AI 요구사항.

- player가 전방에서(Enemy의 앞에서) 가까운 거리에 있는경우 추적한다.
- player가 어디에서든 공격할 경우 추적한다.  => 시야 안에 들었을 뿐만 아니라 초기에 Player에 대한 정보를 가져야 한다. 그래야 Player위치를 추적하니까
	-위 두 사항에서 추적한 지 오랫동안 공격을 하지 못하면 초기 위치로 빠르게 돌아간다. 이때 피격당하지 않는다.
 
- 평상시에는 특정 범위 내에서 랜덤하게(굳이 랜덤하지 않아도 좋다) 패트롤 한다.
- Player가 가까이 있는 경우 근접 공격을 한다.



앞으로 해야할 것 
Enemy AI 개편 O
Player 스킬출력 => 애니메이션 발동되도록 해야한다. X
일부 애니메이션 루트모션 적용 여부 확인 X
피격판정 Zone을 따로 만들어서 처리, 피격판정 시 아래로 꺼지는 것 방지 X

..
Enemy가 Player룰 추적하기위해서 
기존에는 시야에 들었을 경우 Player로 인식하고 추적하였으나 
시야 밖에서 피격당했을 때도 알아차리기 위해서는 처음부터 Player에 대한 정보를 가져야 한다.(만약 솔로플레잉 게임이 아닌경우 이렇게 하면 최적화 문제가 발생하지 않을까)

->Enemy c++ 파일에서 PlayerPlayerPawn = Cast<AMainPlayer>(UGameplayStatics::GetPlayerPawn(this, 0)); 을 통해 플레이어 Pawn의 정보를 가지고 있다. 
그러나 EnemyController 블루프린트에서 사용하였을때 제대로 입력되지 않는다. C++ 코드상에서는 문제없이 작동한다. 일단은 Blueprint에서 같은 변수를 사용하는 것은 포기하고 GetPlayerPawn 함수를 사용해서 할당했다. 
나중에 InitializeComponents 에서 사용하는 것을 고려해본다.

추후 개선점 : 현재 BehaviorTree와 C++로 구현된 상태변화가 가독성이 좋지 못하게 짜여 있음 ex)BlackboardIsDamagedSet => 피격시 true로 되게 하는 것은 C++, false가되는 부분은 Blueprint로 구성됨 

Enemy 와 Player거리가 가까워지면 Enemy 공격 =>
방법:
1. EnemyBlueprint로부터 Player와의 거리 측정 후 BehaviorTree에 관련 Key추가해서 BTT로 애니메이션 밑 공격 구현
2. C++ 에서 Player와의 거리 판단 후 C++에서 공격 애니메이션 재생 
3.C++ 에서 거리 판단 후 BT에서 key 값 변경으로 애니메이션 재생 
--

2,3 을 하기위해서는 Blueprint가 아닌 c++단에서 Player 정보 알고있는게 편리 
따라서 탐색을 통해 Player를 Enemy에 할당하거나 World정보에서 Player 정보를 가져 오면 될 것 

Montage를 통해 코드상에서 공격 애니메이션 작동가능, 두 모션 중 랜덤으로 작동하게 될 것  
FireBall을 관통공격으로 만들어야 할까? => yes 이지만 일단 나중에 
--------
개선 필요사항: 
변수명 규칙이 개판이다. 
Enmey cpp에 공격 및 사망 관련 코드를 BB에 관련된 키(bool값)으로 추가한 후 BT에 적용하여 작동되도록 변경해야함, 이유는 가독성 

처음부터 FSM을 만들고 거기에 대응하는 Key값으로 Behavior트리를 만들었어야 했음을 꺠달음. 하지만 지금와서 고치기엔 어정쩡하므로 추후 개선 
Enemy_AnimBP 의  이벤트 그래프에 Bool값을 받아오는 것으로 적용함 => 이것도 FSM 만들어지면 대체해야 함 

C++로 애니메이션을 제어하려 했더니 UAnimationInstance 클래스가 애니메이션 블루프린트의 부모이다. 이름 한번 참 직관적이다.

모든 애니메이션 이벤트 작업이 끝나고(노티파이를 통한 피격, 공격까지)나면 위에서 언급한 개선점들을 해결한다. 
그 전까지는 거의 기능테스트에 가까운 것 같다. 
FSM 을 먼저 제작을 했더라면 조금 더 작업 속도가 빨랐을 것, BT 만으로 AI를 제작하기는 생각보다 깔끔하게 코드를 짜는것이 쉽지않았다.   
Navigation을 이용해서 RandomPatol을 C++ 로 만들어야 하나? C++로 구현하는것과 Blueprint 로 구현하는 데는 어떤 차이점이 있는건가?=> C++ 과 Blueprint 작업비율 및 분담은 어떻게 해야하는가?

사망 모션이 어색하다. => BT에 사망 관련 키 추가하거나 FSM을 통하여 사망시에는 피격판정을 통한 추격이 안되게 해야한다. 사망시 Destroy판정이 Z 축위치가 아닌 타이머로 하는 것이 더 좋을 것 같다. 
추후 레벨 디자인 할때 더 편리할 수 있을 것 같다.
----

데미지를 왜 float로 만들었을까.. HP를 왜 float으로 만들었을까 => 수정한다, 생각없이 만들면 바로 기술적부채가 된다는 깨닳음을 얻음
해당 기술부채는 수정이 어렵지 않아 바로 해결 할 수 있지만.  다른 부채들은 리팩토링 단계에서 큰 비용을 들이며 지워야 할 것. 기획과 설계 부분이 중요한 이유를 알게 되었다. 지금단계에서 수정하면 
개발기간이 많이 지연 되것이므로 기능 개발을 우선으로 한다. 일단은 굴러가는게 우선이라 판단하였다. 
소프트웨어 설계 부분은 전공책 다시 복습을 해야할 듯하다. 

직렬화에 대한 부분을 알게 되었다 해당 부분에 대해 탐구? 하게되면 Save/Load기능을 구현할 수 있을 것 같다. 

---------AI기능 대 개편 계획---------
2023/08/03

FSM과 BT를 동시에 사용하지 않고 BT만을 이용해서 원하는 방향으로 구현 가능함을 알게 되어 FSM에 집착하지 않아도 된다.
다만 좀 많은 수정이 필요할 것으로 보이다. 원래 생각은 FSM 관리 액터 컴포넌트를 통해 BT의 키 값을 조정하여 AI를 Control하는 것이었으나 
지금 계획은 BT에서 FSM 의 State를 구현하며 키값을 통해 상태이동을 하도록 유도한다. 
FSM,HFSM,BT와 관련된 문서를 참고하였다. BT의 FlowControl 관련 부분도 많은 참고가 필요할 듯 하다.

Enemy가 공격하는 기능을 Enemy.cpp 에서 BT로 이동시킨다. blueprint를 사용해도 좋고 C++을 사용해도 좋으나 
C++을 통해 BlackBoard에 저장된 키 값에 변동을 주어 컨트롤 하는 쪽이 더 코드 관리측면에서 유리할 것으로 사료된다.

BP_EnemyCharacter 에 이미 자신의 Location을 저장하는 변수가 들어있고 이는 Enemy_Controller 블루프린트에서 이용된다는 걸 알아둔다.

-> EnemyController 에 각 상태를 Enum으로 만들어서 함수 하나만 만들어서 각 키값의 true, false 조절을 하려고한다.

현재 BT에 구현된 내용할 내용은  Patrol,Trace, Attack,Damaged, Died, idle(=patrol) 
멀어지면 초기위치로 돌아가는 기능 Toofar 는 이동과 관련된 부분 아래에 적용한다.( ex: 추격중 너무 멀리가면 되돌아온다, 순찰 중 너무 멀어지면 되돌아 온다)

-idle : 아무런 조건이 달성되지 않을 경우 ( 거의 사용되지 않는다)
-patrol : 피격, 시야내 발각, 공격, 상황이 아니면 발동된다. 범위내 랜덤한 지점으로 이동한다.너무 멀리가면 되돌아온다. 이동속도가 기본으로 세팅된다.
-Damaged : 피격 당했을 경우 true, 피격 애니메이션 재생, trace의 키값을 true 로 변경하고 Damaged는 false가 되지 않는다. (= 맞으면 리액션 해주고 쫒아간다.)  
-trace :  시야 내 발각 시 true, Damaged 발동 이후 true, 플레이어를 쫒아간다.이동속도가 올라간다, 플레이어와의 거리가 일정이상 가까워지면 Attack을 true로 바꾼다.너무 멀리가면 되돌아오면서 false.
-Attack: true시 공격 애니메이션을 재생한다.공격 주기(wait)는 1초정도로 한다. 애니메이션이 끝나면 Attack을 false로 한다. 이때 Damaged도 false로 해준다. 기존 C++ 상의 몽타주 재생코드를 함수화 하여 Blueprint상에서 재사용 가능할지? 
-die : HP 가 0가 될 시에 True, 
-isTooFar : 추적 상황에서 초기 위치와 멀어지면 되돌아오도록 한다. Damaged 가 true 였다면 isTooFar가 True라도 돌아가지 않는다.  


이렇게 구성하면 Selector는 왼쪽에서 오른쪽으로 하나라도 기능성공하면 다음 가지를 수행하지 않기 때문에 Attack 기능을 수행중일때 Move가 되지 않도록 할 수 있다. 
지금은 Enemy.cpp 에서 몽타주를 재생하는 기능을 넣었기 때문에 이동하면서 공격모션이 나가는 기괴한 일이 발생하는 것으로 판단된다.

2023/08/07 :BTT_SetEnemyState를 통해 BT에서 Blackboard의 키 값 변경이 쉬워졌다. 
이후 Enemy.h 의 함수 일부(AttackPlayer,DeathState 등)를 EnemyAIController로 옮기는 것이 나은지 고려,
Enemy에 구현된 PlayerAttack, DamageOnProcess등은 이미 C++로 구현되어 있는데 이를 BT에 어떻게 적용해야 하는지에 대한 생각중 
1. 다소 많은 코드정리를 감수하더라도 EnemyController로 이관 
2. BTT 를 C++로 구현하고 그 파일로 기능이관 
3. 그대로 두고 BT와 C++ 연계 (다소 가독성이 떨어지나 이미 가독성은 많이 떨어져있다..) 

3번으로 할 경우 빠르게 진행될 것으로 판단됨, 3번으로 계획을 한다면 C++에서 현재 BlackBoard의 키 값을 읽어오는 방법(GetValueAsBool), 또는 만들어둔 UENUM을 통해서 제어하는 법을 생각해야 할 것
 
 Enemy의 Tick 부분을 변형하여 Blackboard의 키값 IsAttack 과 IsDeath를 변화하도록 함 
BT의 해당 루트 아래에 DeathState,AttackPlayer 함수를 넣고싶음, 해당 방법을 생각 중  
일단 아이디어 하나는 현재 스테이트를 저장하는 변수 하나를 이용하는 것 

 BlackBoard의 키 값을 읽어오는 방법(GetValueAsBool) 이용하여 BT의 isAttack 값을 Tick을 통해 실시간으로 읽어서 작동시키는 법 (굉장히 비효율 적인..) 과 
BTT를 C++로 구현하는 법 등을 고민하고 있음, BlueprintCallable로 구현한 다음 함수를 Blueprint에서 호출하는 것이 좀더 나아보임
후자를 중점으로 언리얼에서 제공하는 함수나 기능을 알아보도록한다. BT에서 Selector로 해당함수가 불리고 있을때 Tick이 어떻게 작용하는지?(몽타주 재생 간격에 대해) 안될 경우 Wait를 이용해야하나? 
 BTT Node를 C++로 구현하기 위한 밑 작업, BT에 의해 실행되는 기능이다. BTT Node에서 구현을 위해 필요한 함수정보를 알아본다.

BTTaskNode 에서 Enemy의 함수를 불러오는 것으로 간단하게 구현하였다. 

개선해야하는 점:
문제 1. 초기 위치로 돌아갈때는 데미지를 입지 말아야한다.(해당 상태일때 피격 비활성화하는 코드를 넣는 시도를 할 것), 초기로 돌아가면 HP 회복 되었으면 좋겠다.
문제 2. Trace 상태일때 피격 모션이 표시 되지 못함 => BT의 우선순위 문제 (Damaged 시퀀스의 우선순위를 높여본다, 관찰자 중단 옵션을 잘 조절해본다 ) : 해결됨 
문제 3. 공격모션이 가끔 이어지지 않는 문제 (해결됨)
문제 4. Enemy의 몽타주 재생이 끝날때까지는 움직이지 않았으면 함 => Attack 노드 수행중일때 C++ 에서 몽타주가 끝날때까지는 Succesed 를 반환 하지 않도록 한다면?  
OnAttackEnd 노티파이가 불려야 다음BTT로 넘어가게 한면 될까? 
=> 안된다 
TickTask를 이용하는 방법을 생각중. => 실패 하였다 


기존의 Play Animation 노드는 애니메이션이 끝나야 다음 노드로 넘어가는 듯 하다
이를 어떻게 응용할 방법 없을까 

문제 4 해결방안 시도.
Attack 코드에 쿨타임 대신 Delay(wait)를 이용하는 방법을 시도할 예정이다.
-> 현재 재생중인 몽타주섹션의 플레이 길이를 알아내는 함수getMontageSectionPlaytime(int32 index)를 구현 (일단 보류)

AttackToPlayer 에서 
TickTask를 이용하여 Attack 함수를 Tick 적인 호출에서 제외 Attack을 한번 호출 하는 것으로 함 다만 지속적으로 Attack 이 불리기에 Bool 변수를 이용해서 컨트롤 
애니메이션 인스턴스, Enemy, AttackToPlayer 등의 cpp 파일 변경사항 발생 

추가 개선사항 : 기능 구현 이후 레벨디자인을 할때 is TooFar true 거리를 플레이어의 최대 공격길이 보다 길게 할 것, 피격 될 때마다 피격 모션을 재생할 수 있도록 할 것

<문제해결>
멀어지면 몽타주를 바로 멈추게 하는 if문에 몽타주 재생과 관련된 조건을 추가함
Tick 함수에서 가까워지면 계속 상태를 isAttack으로 만드는 If문에 조건을 달아 문제를 해결했다.
엑셀 밟고 있으면서 자동차 휠을 잡으면 그게 멈춰질까.. 
다음부터는 문제가 있으면 코드리뷰 꼼꼼히 해야겠다..
수치스럽다. 

코드 한줄이다 한줄만 수정하면 고쳐질 것을 5일 동안 뻘짓했다는게 한심스럽다. 
그래도 ..이거저거 하면서 다양한 것들을 알게 되기도 했고 겸사겸사 코드도 최적화?가 되었으니까 
긍정적으로 생각하면 마냥 나쁘진 않다고 볼 수 있지 않을까 ...

심적인 여유가있어야 시야가 넓어지는 것 같다.. 


-개선사항까진 아닌 것 - 

공격판정이 Attack 노티파이가 불리는 한 순간 뿐인데 판정 프레임 길이를 생각을 못했지만 이대로 두는 것도 좋아보임  
---------------------------------------------------------------------------------------------------------
플레이어 피격 이벤트 

Enemy의 전방에 Collision Box를 설치하고 애니메이션 노티파이를 이용하여 애니메이션 특정구간에서 충돌 판정이 나면 플레이어가 데미지를 입도록 하려한다.
Ex) Enemy의 공격 애니메이션 재생중 Enemy의 Collision Box(Attack Box)에 Player의 hitBox가 겹치는 경우 플레이어는 데미지를 입는다 
>>Animinstance 에 AnimNotify_노티파이명 멤버함수만들어서 호출 가능함

Box에 Player의 Hitbox가 Overlap 되어있는  상태 (bool로 판정하지 않을까 싶음)에서 -> Notify 에서 발동 이때 앞의 Bool이 true = Overlap 판정이면 데미지 주는 방식

하기에 앞서 플레이어에게 HP를 설정한다. Enemy에게도 공격력을 부여하였다.

Enemy의 피격 존은 그대로 두고 Player의 피격존을 따로 관리해야하나? => 일단 따로 만들어서 나쁠 것은 없다고 보고 그렇게 만들도록 한다. 

개선사항 : 피격시 이펙트를 추가했으면	

09/05 => 어차피 Enemy의 공격모션은 특정 조건에서만 발동 되는데 굳이 Overlap판정에 목을 매어야 하나? 라는 근본적인 질문을 했지만 그래도 Overlap을 통한 판정을 해야 이후 플레이어의 회피를 추가할 수 있다.


 이때 플레이어의 피격 반응 애니메이션과 약간의 경직 효과를 주고 싶다. 
OnDamageProcess => 피격 몽타주 재생 => MainPlayer에 입력을 허용하고 막는 것을 조절하기 위한 함수를 생성 => 피격 몽타주와연결된 노티파이에서 호출 할 예정 

맞으면 키 입력과 이동입력이 작동되지 않게 하고, 이동 중 맞을시 정지 되도록 코드를 추가, 수정함 

피격중 몽타주 재생중 커맨드를 선입력하는 편이 더 재밌어 보여서 피격중에 커맨드 입력은 막지 않았다.  

의문점 : 어쨰서 에디터 실행시에 Player 몽타주를 찾았다는 로그가 여러번 뜨는거지? 

--------------------------------------------------------------------------------------------------------------------------
플레이어의 스킬 사용 이벤트 

플레이어 피격과 비슷하게 AnimInstance 클래스를 상속받은 MainPlayerAnim에서 몽타주 재생, 노티파이 함수 정의 하여 구현함 

회피스킬 앞구르기 백스텝 등은 Player의 HitBox를 비활성화 시키는 것으로 가능 할 것 같다.

AnimGraph에서 몽타주 두개를 부른다? 이건 좀 그렇긴해서 스테이트 머신을 사용하는 방법은 어떻까 생각하는 중..
그렇게 될 경우 idle 에서 모든 상태로 바뀔 수 있어야 하는데 스킬의 갯수가 늘어나면 관리가 복잡해 보이고 
Default 하나에 몽타주 여러개 일렬로 줄줄이 달려있는 것도 좋아보이진 않음 ...

1. 몽타주 섹션별로 Play를 하여 애니메이션 관리 
2.  몽타주를 AnimGraph에다 죄다 때려박아서 Play
3. AnimGraph의 스테이트를 하나 추가하기, 이때 정수로 블렌드하기 기능으로 만들면? 

3번으로 구현하는 것이 제일 깔끔해 보임, 3번으로 진행 하려면 기존에 몽타주로 재생했던 부분중 공격과 관련된 부분은 몽타주 재생이 아니라 
애니메이션 재생이 될 것, 이 부분은 AnimGraph로 대체할 수는 있을 수도 있으나 몽타주로 재생하는 방법이 더 빠르게 될 것으로 보여 1번 방법을 선택함 

모든 스킬 모션을 몽타주로 만들고 이를 사용한다고 할때 AnimGraph의 가독성은 보장되는가? 

장풍(FireBall)은 주요 부분이 전부 구현 완료되었음
 
HurricaneKick 같은 플레이어의 물리공격의 구현에 대해..
1. skeleton에 collisionComp를 달아서 공격스킬 발동시 해당 collision에 Enemy가 닿을때 데미지주는 방법?
2. 제일 가까운 Enemy와의 거리가 특정부분 이하일때 Damage // 제일 비 효율적이라고 생각함 
3. Enemy와 같은 방법으로 각 스킬별로 공격판정 Zone을 두어 활성화/비활성화 

1번으로 진행 하였을 경우: 공격 스킬을 많이 추가할 경우 편리할 수 있다. 코드의 재활용이 잘 될 것 같다. 
3번으로 진행할 경우 Enemy에서 사용한 코드 바로 재활용 가능할 듯, 다만 공격과 관련된 스킬이 많아질 수록 많은 양의 공격판정 Zone을 만들어야한다.  
2번은 논외로 한다. 

1번으로 진행해본다. 

개선사항:
이 과정에서 코드가 겹치는 부분이 생겼다, 이를 함수화 할 수 있으면 하는 게 좋을 것으로 보인다.
hurricaneKick의 공격판정이 좋지 않다

아쉬운 사항 : DataTable -> 델리게이트 -> 함수 ->  MainPlayer ->Firball 또는 AnimNotify_Attack 의 흐름으로 데미지 값이 전달 되는데 
다소 복잡하고 효율적이지 못해 보임 

★애니메이션 노티파이를 이용하여 발동과동시에 특정 구간까지만 키 입력을 받지 못하도록 하는 것이다. 선입력을 위해서 애니메이션 마지막 몇  프레임에서는 입력이 되어야 한다. 


Montage_Play(fireBallMontage, 1.0f, EMontagePlayReturnType::MontageLength, 0.0f, true);
Montage_JumpToSection("FireBall", fireBallMontage);  
mMainPlayer->AllowInput(false);
mMainPlayer->GetController()->StopMovement();
을 함수 하나로 만들었다.

Enemy 피격시 넉백 되도록 하는 함수를 추가하여 특정 스킬에 맞으면 뒤로 밀려나게 할 것, 이 함수만 추가하면 피격시 넉백되도록..On/Off 방식으로 만들고 싶다. 
넉백을 발동시키는 함수는 Player와 Enemy 둘중 어느쪽에 있어야 하는가? 

/*
Player의 스킬 공격에 대한  Enemy 넉백에 대하여
 
넉백이 있어야 하는 이유 : Enemy의 피격에 대한 반응성이 더 좋으니까. 
추가하고자 하였지만 여러 이유로 잘 되지 않았다. 
그래서 일단 나중으로 미루고 단순하게 Player와 Enemy의 벡터를 이용하여 Player의 반대 방향으로 Enemy의 위치를 뒤로 옮기는 수준으로 구현 할 것 
*/
Unreal에서 무료 배포중인 Paragon 사용고려 but 
PC의 남은 용량이 부족,Paragon 캐릭터들의 애니메이션 이질감(?) 으로  애니메이션은 MIXAMO 이용 할 계획 , 


언리얼 라이브러리에 이달의 무료로 받은 공격 모션이 있을 것, 또한 다른 무료컨텐츠에서 애니메이션을 받아 이주하여 공격 스킬의 다양화를 시도할 것
=> 지금까지 만든 함수의 유틸성 테스트? 같은 느낌으로.. 뼈대는 만들었으니까 살 붙이기 같은 느낌

테스트용 프로젝트에 리소스를 받고 필요한 것만 본 프로젝트에 이주하도록 하여야 한다.

다단히트 아이디어: START이후 END까지 X초 마다 공격판정(미구현)

본인은 코드를 짤때 범용성 있게 짤 수 있도록 노력해야한다.


현재 구현된 것 
원거리 공격:JangPoong(이것도 언젠간 이름 바꿔야하는데..) 
근거리 다단히트 공격: HurricaneKick(from Mixamo)
근거리 단일공격 : 일명 평타 (범위가 짧지만 커맨드가 간단하고 공격 발동이 빠르다, 피격 경직일때 역공하기에 용이한 구조) 
회피기(이것은 유일 쿨타임이 있는 스킬, 모든 피격 판정을 무시하고 회피, 스페이스바 발동(앞구르기)
전진성 있는 단일 공격 : 이동기로 사용 가능한.. 

플레이어의 사망

0924 : Player 사망, Flying Kick애니메이션 추가 하였으니 구현 바람
0926 : FlyingKick 등의 루트모션 적용시 문제발생, 루트모션이 아닐때와 다른 움직임을 보이거나 애니메이션이 끝났을 때 플레이어 캐릭터가 기울어져있는 문제
루트모션이 기존 애니메이션과 다르게 나오는 부분은 리타게팅 과정에서 문제가 발생한 것으로 보임, 해결방안이 떠오르지 않음  
루트모션 애니메이션이 끝났을때 기울어진 문제는 강제적으로 기울기를 조정하면 될 것으로 보임 

0928 : 교재를 따라하지 않고 Blender 의 Addon 을 사용하는 방법을 이용하여 Mixamo 애니메이션 및 메시 등을 변환하는 것으로 해결하였다. 
이전에 같은 방법으로 시도했지만 안되어 교재내용대로 하였으나 어쨰서인지 지금은 잘 작동한다..
문제는 교재에는 리타기팅 설정중 Root 에  None 을 넣을 수 밖에 없었지만 Addon에서는 Root 본을 추가해주기 때문에 문제가 해결된 것으로 보인다. 

다만 리타게팅을 하는 과정에서 HurricaneKick의 루트모션 옵션이 작동하지 않아 새로 적용해야한다.

0929 : 애니메이션 블루프린트를 적용하면 메시가 추가적으로 90도 돌아가는 버그가 발생하여 새 애니메이션을 적용하는데 애로사항이 있었다. 
이를 해결하기위해 0928로 버전을 되돌리고 Player에 적용된 메시와 애니메이션 블루프린트를 해제하고 다시 Mixamo에서 캐릭터를 다운받아 Blend 의 Addon을 통하여 
임포트와 리타게팅을 진행하여 해당 버그를 고칠 수 있었다.


개선해야하는 점 (추가하고 싶은 부분): 스테미너 게이지를 추가하여 스테미너가 될 경우에만 스킬사용(시간적으로 가능한 경우), 스테미너는 스테미너 회복 스킬(이동및 공격 불가)을 사용 중일때 충전된다, 각 스킬 관련 기능들을 함수 하나로 줄여서 쓸 수 있을것(반복되는 코드 함수화) 

후회되는 점 : 스켈레탈메시에 공격판정을 붙이니 잘 맞지 않는다.(구체 콜라이더를 쓰는 것도 고려했어야) + 애니메이션의 특정 타이밍에만 공격판정을 주는 것 (뭔가 있어보이려고 하다가 판정이 잘 안맞는다)

개선 아이디어: 
근접공격 애니메이션에 노티파이를 3개로 나누어 적용한다, ⓐ공격판정시작 ⓑ공격판정끝 ⓒ다단히트 구현히 추가 판정지점 
a 이후로 Collision 에 닿으면 피격 판정, b 이후로는 판정 없음, c 는 a이후b 이전에 불러와서 닿고있으면 피격 판정 추가 

또는 

BoxCollider를 활성화하는 노티파이를 애니메이션에 넣어서 특정 부분부터 Overlap되면 데미지 입게하기 << 이 방식 으로 코드를 수정하는 것은 쉬워보이나 다단히트는 어떻게? 

1004 : 어째서인지 루트모션을 적용하면 움직임이 특정 범위 내로 축소된다. 장거리 이동 공격인 Flying Kick에서 해당 오류가 발생하여 의미가 없게 되었다.
1005 : "flying" kick이니까 Movement component에서 flying 모드로 하면 해결되지않을까? => 해결됨

노하우 : 생성자에서 추가, 변경 된 사항 있을 시 UnrealEngine을 끄고 ctrl + F5로 다시 에디터를 시작하면 생성자가 알아서 초기화 된다. 
생성자 변경으로 인한 각종 에러들을 예방 할 수 있다. Mixamo의 애니메이션을 쓸때는 Blender 의 애드온으로 루트 본을 추가하여야 모션 에러를 방지할 수 있다.

MeleeJumpAttack,BackJump 모션은 Boss의 스킬로 구현 예정 (Ex: 플레이어와의 거리가 일정수치 이하면 30% 확률로 백점프 회피)

	//이 아래 네 줄의 코드를 함수화 할 수 있을것 
	PlayerTempBox = PlayerFootBox;
	AttackZoneControl(PlayerTempBox,true);

	Playeranim->SkillSequence(1.5f, "HurricaneKick");
	mPlayerPower = Damage;
-----------------------------------------------------------------------------------------------------------------------
0917 : 언리얼 정수형은 Int32 였었지.. 뒤늦게 수정 .. 
0919 : EnemyDeath State도 tick 으로 해야 할 듯 
0921 : C#에는 Property를 어떻게 사용하나 
0924 : Enemy AI에서 버그 발견 수정작업 진행(is too far관련) 및 수정 완료, 
원인 : AI최종 수정 후 언리얼 에디터가 튕기면서 일부 변경사항 저장 안된 것으로 보고있음 
0926 : 매개변수에 포인터 변수가 쓰인경우(내용이 바뀌지 않는 경우) 내가 const를 사용했나? 
----------------------------------------------------------------------------------------------------------------------
레벨디자인 시에 Kill Zone 을 통해서 의도치 않게 Enemy 또는 Player가 추락할 경우에 대비할 것 

----------------------------------------------------------------------------------------------------------------------
보스몬스터 제작 

해야하는 것(아마 c++코드보다 BP 작업에 중점을 둘 것 같은 느낌, 블루프린트로도 퀄리티 높게 만들 수 있다 생각함) 

- Boss 몬스터의 행동양식 즉 AI 제작 => FSM같은 거 없이 순수BT 로만 도전, Enemy보다 단순화 (Player가 어디에 있든 추적, 공격 범위 내 있으면 공격, 상황에 따라 스킬사용) 
- 공격 피격 제작, 플레이어 공격을 구현하면서 아쉬웠던 부분을 여기서 구현해보기 (Collider를 활성화하는 노티파이를 애니메이션에 넣어서 특정 부분부터 Overlap되면 데미지 입게하기)
	- 공격 범위는 무기에, 피격시 반응도 추가, Overlap되는 오브젝트가 무엇인지보다 Tag 비교를 통해 데미지를 구현 하도록 변경  
-사망 구현(클리어 구현) 	 


이미 애니메이션 소스가 충분하므로 리타게팅 하여 다른 애니메이션을 쓰려고 할 필요가 없을 것으로 보인다.
다만 원 소스가 숄더뷰(?)TPS 게임의 플레이어블 캐릭터라는 점에서 스킬 모션이나 이펙트 같은 부분에서 본 프로젝트와 어울리지 않는 애로사항이 있을 것 같다. 

이 작업이 끝나면 UI/UX, 이펙트 추가 등 뚜껑을 닫는 단계로 돌입할 것  


보스 AI

1. 항상 플레이어를 추격 
2. 체력에 따라 공격 및 이동 속도 향상 (공격속도가 다른 두 애니메이션이 이미 존재함)
3. 플레이어와 거리가 일정 이하일경우 일반공격
4. 플레이어의 거리가 멀 경우 


작업 착수하면서 생각하여 보니  
이미 Enemy를 작업하면서 필요한 기능 구현되어있음 

=> Enemy.h 상속을 통해서 기능확장 및 수정 하기
 또는
 EnemyBase 동적 컴포넌트를 만들어서 Enemy와 Boss 구현 

일단은 작업을 빨리 진행하기위해 Enemy.h 파생 C++ 구현해보는 것으로 

Enemy.h->Enemy.cpp
       ->BossMonster.cpp

피격시 OnDamageProcess 를 작동시키는 단계 
Player는 Overlap된 객체를 AEnemy로 캐스트하기때문에 OnDamageProcess가 AEnemy의 것으로 호출 => 오류발생 

조건에 따라 캐스트를 ABossMonster로 하는 코드를 추가하게 되면 해결 될 문제지만, 만약 적의 종류가 많아지면? 
일일히 다 Cast? 얼마나 많은 헤더파일을 Include? >> 다른 방법을 최대한 강구해보자 

모듈화가 되지 않아 Animation, Controller,Enemy(Player) 간의 응집성 큼 

 MainPlayer가 때린 캐릭터에 따라 OnDamageProcess가 각각 다른 클래스로 적용되게 하였다.
사실 OnDamageProcess 는 상속 그대로 받았기 때문에 어떻게 잘만 하면 될거 같은데.. 
프로젝트 마무리단계에서 코드를 모듈화 또는 리팩토링 하면서 정리를 잘 해보면 될 것 같은 느낌 
=> 코드 재활용 및 개발속도 측면에 있어서 상속은 생각보다 크게 도움이 되지 않았다, 
모듈화 또는 기능별로 쪼개서 컴포넌트화를 하는게 정답이었던 것 같다. 무엇보다 컴파일 시간이 훨씬 늘어난 느낌 

최대한 BP를 이용해서 Boss를 컨트롤해보려고 한다. 이유는 Enemy 에서 충분히 C++을 이용해서 
이번에는 BP를 최대한 이용해보는 방향

Boss 의 움직임이 끊기듯 움직이는 것 개선해야한다. Controller 또는 BP에서  항상 플레이어 방향을 보게 하면 해결 될 것 같다.

커스텀 데코레이터를 블루프린트로 구현하는 법을 알게 되어 이를 이용하여 플레이어와의 거리에 따라 추격 또는 공격을 하도록 했다.
이것을 응용하면 HP 에 따라 다른 공격 패턴 또는 사망, 이동속도 변화 등을 줄 수 있을 것 같아 그렇게 구현하도록 시도한다.

Simple parallel 노드를 이용해서 움직이면서 공격하는 기능 구현(적용은 하지 않음)
PlayAnimation 대신 몽타주를 재생하게 하는 방향 생각중 

AI 개발 후 애니메이션 작업을 하는 방향으로 작업순서 설정 
..	
상하체 움직임이 자연스럽도록 원본 Grux 애니메이션 블루프린트를 참고하여 
조정해볼 것 

상속관계에서 델리게이트로 코드를 재사용할 수 있을까...
Tick에서도 같은 코드를 쓰는데 fMeleeAttackRange가 걸리네 ..
근데 그거 BP에서 그냥 조정하면 되는거 아님? => 맞음 
결과 => 코드재활용  
생각해보니 만족스러움 

controller, Anim 또한 BossMonster.cpp 와 같이 상속을 잘 이용해 볼 것  
현재 BP_BossController의 BlackBoardComp1 을 삭제하면 Null 오류 
-> 근데 BP_Enemyontroller 에서는 블랙보드 컴포넌트를 따로 추가한 적이 없음 

무슨 차이인지 알아보고 테스트 계속할 것

테스트가 예상대로 끝나면 테스트파일을 적용파일로 대체 할 것 

AttackToPlayer에서 Attack()을 불러오는데 NullPointer 오류 발생하여 문제파악
원인 => ControlledEnemy에 값이 제대로 캐스트 되어 들어가지 않음 
이유 -> 상속
해결 => 클래스 이름비교

깨달음 : 상속은 하드코딩적요소가 많다. 되도록 자제, 모듈화할 것, 언리얼에는 Get Class라는 편리한 함수가있다.. 
노하우 : 저장하고 바로 테스트하지 말것, PureFunction 
